<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Sefaria Screen Reader</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      background: #f8fafc;
      color: #0f172a;
    }
    .panel {
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      max-width: 640px;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.12);
    }
    h1 {
      margin: 0 0 12px;
      font-size: 20px;
    }
    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px;
    }
    input,
    select {
      flex: 1 1 220px;
      padding: 8px 10px;
      border: 1px solid #cbd5f5;
      border-radius: 8px;
      background: #f1f5f9;
    }
    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #cbd5f5;
      background: #e2e8f0;
      cursor: pointer;
      font-weight: 500;
    }
    button.primary {
      background: #0f172a;
      color: #fff;
      border-color: #0f172a;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .status {
      font-size: 14px;
      min-height: 20px;
      margin-bottom: 12px;
      color: #64748b;
    }
    .status.success { color: #047857; }
    .status.error { color: #b91c1c; }
    .content {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 12px;
      background: #fdfcfe;
      min-height: 120px;
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .ref-line {
      font-weight: 600;
      margin-bottom: 8px;
    }
    .he {
      direction: rtl;
      font-size: 18px;
      margin-bottom: 12px;
    }
    .en {
      font-size: 16px;
    }
    .lang-options {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .lang-options label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      cursor: pointer;
    }
    .voice-row label {
      flex: 0 0 140px;
      font-size: 14px;
      color: #475569;
    }
    .controls-row button {
      flex: 1 0 120px;
    }
    .subtext {
      font-size: 13px;
      color: #475569;
      margin-top: -6px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <main class="panel">
    <h1>Sefaria Screen Reader</h1>
    <div class="row" style="display: none;">
      <label style="font-size:14px;">Current ref:</label>
      <input id="sref" type="text" readonly placeholder="waiting…" />
      <button id="request-ref">Request ref</button>
    </div>
    <div class="row">
      <label style="font-size:14px;">Read language:</label>
      <div class="lang-options" id="language-options">
        <label><input type="checkbox" name="reader-language" value="en" id="lang-en" /> English</label>
        <label><input type="checkbox" name="reader-language" value="he" id="lang-he" /> Hebrew</label>
        <label><input type="checkbox" name="reader-language" value="both" id="lang-both" /> Both</label>
      </div>
    </div>
    <p class="subtext">Pick which languages to read. Selecting "Both" will play English followed by Hebrew for each segment.</p>
    <div class="row voice-row">
      <label for="voice-en">English voice:</label>
      <select id="voice-en">
        <option value="">Loading browser voices…</option>
      </select>
    </div>
    <div class="row voice-row">
      <label for="voice-he">Hebrew voice:</label>
      <select id="voice-he">
        <option value="">Loading browser voices…</option>
      </select>
    </div>
    <p class="subtext">Voices come directly from your browser / OS speech synthesis API.</p>
    <div class="row">
      <label for="rate-slider" style="font-size:14px;">Speech speed:</label>
      <input id="rate-slider" type="range" min="0.5" max="2" step="0.1" value="1" />
      <span id="rate-value" style="min-width:50px;font-size:14px;">1.0×</span>
    </div>
    <div class="row controls-row">
      <button id="play-btn" class="primary">Play</button>
      <button id="pause-btn" disabled>Pause</button>
    </div>
    <div id="status" class="status">Waiting for reference…</div>
    <section id="content" class="content">No text loaded yet.</section>
  </main>

  <script>
    const srefInput = document.getElementById('sref');
    const requestBtn = document.getElementById('request-ref');
    const statusEl = document.getElementById('status');
    const contentEl = document.getElementById('content');
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const languageInputs = Array.from(document.querySelectorAll('input[name="reader-language"]'));
    const langEn = document.getElementById('lang-en');
    const langHe = document.getElementById('lang-he');
    const langBoth = document.getElementById('lang-both');
    const voiceSelectEn = document.getElementById('voice-en');
    const voiceSelectHe = document.getElementById('voice-he');
    const rateSlider = document.getElementById('rate-slider');
    const rateValue = document.getElementById('rate-value');

    let currentSref = '';
    let currentPayload = null;
    let activeUtterance = null;
    const supportsSpeech = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    const synth = supportsSpeech ? window.speechSynthesis : null;
    let voices = [];
    const playbackState = {
      state: 'idle' // idle | playing | paused
    };
    let speechRate = parseFloat(rateSlider.value) || 1;
    const params = new URLSearchParams({
      context: '0',
      stripItags: '1',
      fallbackOnDefaultVersion: '1'
    });
    const htmlStripper = document.createElement('div');

    function setStatus(message, type = '') {
      statusEl.textContent = message;
      statusEl.className = 'status' + (type ? ' ' + type : '');
    }

    function stripHtml(raw) {
      if (raw == null) return '';
      if (typeof raw !== 'string') {
        return stripHtml(String(raw));
      }
      htmlStripper.innerHTML = raw;
      const text = htmlStripper.textContent || htmlStripper.innerText || '';
      htmlStripper.textContent = '';
      return text.trim();
    }

    function removeDevineName(text) {
      if (typeof text !== 'string') return text;
      // Match י followed by any number of Hebrew marks, then ה, then any number of marks, then ו, then any number of marks, then ה, with optional marks between/after
      const replacedText = text.replace(/י[\u0591-\u05C7]*ה[\u0591-\u05C7]*ו[\u0591-\u05C7]*ה[\u0591-\u05C7]*/g, 'אֲדוֹנַי');
      console.log(replacedText);
      return replacedText;
    }

    function flattenText(value) {
      if (!value) return '';
      if (Array.isArray(value)) {
        return value.map(flattenText).filter(Boolean).join('\n').trim();
      }
      if (typeof value === 'object') {
        if ('text' in value) return flattenText(value.text);
        if ('he' in value) return flattenText(value.he);
        if ('content' in value) return flattenText(value.content);
        return '';
      }
      return stripHtml(value);
    }

    function formatRef(ref) {
      if (!ref) return '';
      return ref.replace(/_/g, ' ');
    }

    async function fetchSefariaText(ref) {
      const url = `https://www.sefaria.org/api/texts/${encodeURIComponent(ref)}?${params.toString()}`;
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Sefaria API error (${response.status})`);
      }
      const data = await response.json();
      if (data && data.error) {
        throw new Error(data.error);
      }
      return {
        ref: formatRef(data.ref || ref),
        heRef: stripHtml(data.heRef || ''),
        hebrew: flattenText(data.he),
        english: flattenText(data.text)
      };
    }

    async function renderRef(ref) {
      if (!ref) {
        contentEl.textContent = 'No text loaded yet.';
        currentPayload = null;
        return;
      }
      setStatus('Loading text…');
      contentEl.textContent = 'Fetching text…';
      try {
        const payload = await fetchSefariaText(ref);
        const { ref: cleanedRef, heRef, hebrew, english } = payload;
        contentEl.innerHTML = '';
        currentPayload = { ref: cleanedRef, hebrew, english };

        const refLine = document.createElement('div');
        refLine.className = 'ref-line';
        refLine.textContent = cleanedRef || ref;
        contentEl.appendChild(refLine);

        if (heRef && heRef !== cleanedRef) {
          const heRefLine = document.createElement('div');
          heRefLine.className = 'ref-line';
          heRefLine.textContent = heRef;
          contentEl.appendChild(heRefLine);
        }

        if (hebrew) {
          const heBlock = document.createElement('div');
          heBlock.className = 'he';
          heBlock.textContent = hebrew;
          contentEl.appendChild(heBlock);
        }

        if (english) {
          const enBlock = document.createElement('div');
          enBlock.className = 'en';
          enBlock.textContent = english;
          contentEl.appendChild(enBlock);
        }

        if (!hebrew && !english) {
          contentEl.textContent = 'No text returned for this reference.';
        }

        setStatus('Loaded', 'success');
        if (playbackState.state === 'playing') {
          speakCurrentSegment();
        }
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Failed to load text.', 'error');
        contentEl.textContent = 'Unable to display text.';
        currentPayload = null;
      }
    }

    function handleSrefUpdate(newRef) {
      currentSref = (newRef || '').trim();
      srefInput.value = currentSref;
      if (!currentSref) {
        setStatus('Waiting for reference…');
        contentEl.textContent = 'No text loaded yet.';
        currentPayload = null;
        return;
      }
      if (playbackState.state !== 'idle') {
        stopSpeaking(true);
      }
      renderRef(currentSref);
    }

    function enforceSingleLanguageSelection(target) {
      if (!target.checked) {
        // Always keep one selection active
        target.checked = true;
        return;
      }
      languageInputs.forEach((input) => {
        if (input !== target) {
          input.checked = false;
        }
      });
    }

    function getLanguagePreference() {
      const selected = languageInputs.find((input) => input.checked);
      if (!selected) return 'both';
      return selected.value;
    }

    function populateVoiceSelect(selectEl, langPrefix) {
      if (!supportsSpeech) return;
      const locale = langPrefix.toLowerCase();
      const filtered = voices.filter((voice) =>
        voice.lang.toLowerCase().startsWith(locale)
      );
      const list = filtered.length ? filtered : voices;
      selectEl.innerHTML = '';
      if (!list.length) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No voices available';
        selectEl.appendChild(option);
        selectEl.disabled = true;
        return;
      }
      list.forEach((voice) => {
        const option = document.createElement('option');
        option.value = voice.name;
        option.textContent = `${voice.name} (${voice.lang})${voice.default ? ' • default' : ''}`;
        selectEl.appendChild(option);
      });
      selectEl.disabled = false;
      if (!selectEl.value && list[0]) {
        selectEl.value = list[0].name;
      }
    }

    function refreshVoices() {
      if (!supportsSpeech) return;
      voices = synth.getVoices();
      voices.sort((a, b) => a.name.localeCompare(b.name));
      populateVoiceSelect(voiceSelectEn, 'en');
      populateVoiceSelect(voiceSelectHe, 'he');
    }

    function getVoiceFromSelect(selectEl) {
      if (!supportsSpeech) return null;
      const target = voices.find((voice) => voice.name === selectEl.value);
      return target || null;
    }

    function updateControls() {
      const playing = playbackState.state === 'playing';
      const paused = playbackState.state === 'paused';
      playBtn.disabled = !supportsSpeech;
      pauseBtn.disabled = !supportsSpeech || (!playing && !paused);
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    }

    function stopSpeaking(keepPlaybackState = false) {
      if (supportsSpeech) {
        synth.cancel();
      }
      activeUtterance = null;
      if (!keepPlaybackState) {
        playbackState.state = 'idle';
      }
      updateControls();
    }

    function requestNextSegment() {
      console.log('Requesting next segment');
      window.parent.postMessage(
        { type: 'plugin:navigate-segment', direction: 'next' },
        '*'
      );
    }

    function speakTextBlock(text, lang, voice) {
      return new Promise((resolve, reject) => {
        if (!supportsSpeech) {
          resolve('unsupported');
          return;
        }
        const trimmed = (text || '').trim();
        if (!trimmed) {
          resolve('empty');
          return;
        }
        const utterance = new SpeechSynthesisUtterance(trimmed);
        if (voice) {
          utterance.voice = voice;
        }
        if (voice && voice.lang) {
          utterance.lang = voice.lang;
        } else if (lang) {
          utterance.lang = lang;
        }
        utterance.rate = speechRate;
        utterance.onend = () => {
          if (activeUtterance === utterance) {
            activeUtterance = null;
          }
          resolve('done');
        };
        utterance.onerror = (event) => {
          if (activeUtterance === utterance) {
            activeUtterance = null;
          }
          console.error('Speech synthesis error', event);
          reject(event.error || 'Speech synthesis error');
        };
        activeUtterance = utterance;
        synth.speak(utterance);
      });
    }

    async function speakCurrentSegment() {
      debugger;
      if (!supportsSpeech) {
        setStatus('Speech synthesis is not supported in this browser.', 'error');
        return;
      }
      if (!currentPayload) {
        if (!currentSref) {
          setStatus('No reference to read. Click "Request ref" to load text.');
        } else {
          setStatus('Waiting for text to read…');
        }
        return;
      }

      const preference = getLanguagePreference();
      const sequence = [];
      if (preference === 'en' || preference === 'both') {
        sequence.push({
          text: currentPayload.english,
          lang: 'en',
          voice: getVoiceFromSelect(voiceSelectEn)
        });
      }
      if (preference === 'he' || preference === 'both') {
        sequence.push({
          text: removeDevineName(currentPayload.hebrew),
          lang: 'he',
          voice: getVoiceFromSelect(voiceSelectHe)
        });
      }

      const hasContent = sequence.some((block) => (block.text || '').trim().length);
      if (!hasContent) {
        setStatus('Selected language is unavailable for this segment.', 'error');
        if (playbackState.state === 'playing') {
          requestNextSegment();
        }
        return;
      }

      setStatus('Reading current segment…');
      for (const block of sequence) {
        try {
          await speakTextBlock(block.text, block.lang, block.voice);
        } catch (err) {
          setStatus(typeof err === 'string' ? err : 'Unable to read segment.', 'error');
          stopSpeaking();
          return;
        }
        if (playbackState.state !== 'playing') {
          return;
        }
      }

      if (playbackState.state === 'playing') {
        setStatus('Advancing to the next segment…');
        requestNextSegment();
      }
    }

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'sref:update' || data.type === 'sref:response') {
        handleSrefUpdate(data.sref || '');
      }
    });

    requestBtn.addEventListener('click', () => {
      window.parent.postMessage({ type: 'plugin:request-sref' }, '*');
    });

    playBtn.addEventListener('click', () => {
      if (!supportsSpeech) {
        setStatus('Speech synthesis is not available in this browser.', 'error');
        return;
      }
      stopSpeaking(); // reset any existing speech
      playbackState.state = 'playing';
      updateControls();
      if (!currentSref) {
        setStatus('Requesting reference…');
        window.parent.postMessage({ type: 'plugin:request-sref' }, '*');
        return;
      }
      speakCurrentSegment();
    });

    pauseBtn.addEventListener('click', () => {
      if (!supportsSpeech) return;
      if (playbackState.state === 'playing') {
        synth.pause();
        playbackState.state = 'paused';
        setStatus('Playback paused.');
        updateControls();
      } else if (playbackState.state === 'paused') {
        synth.resume();
        playbackState.state = 'playing';
        setStatus('Resuming playback…');
        updateControls();
        if (!synth.speaking) {
          speakCurrentSegment();
        }
      }
    });

    languageInputs.forEach((input) => {
      input.addEventListener('change', () => enforceSingleLanguageSelection(input));
    });
    langBoth.checked = true;

    function updateRateDisplay() {
      rateValue.textContent = `${speechRate.toFixed(1)}×`;
    }

    if (!supportsSpeech) {
      setStatus('Speech synthesis is not supported in this browser.', 'error');
      playBtn.disabled = true;
      pauseBtn.disabled = true;
      rateSlider.disabled = true;
    } else {
      refreshVoices();
      if (typeof synth.addEventListener === 'function') {
        synth.addEventListener('voiceschanged', refreshVoices);
      } else {
        synth.onvoiceschanged = refreshVoices;
      }
    }

    rateSlider.addEventListener('input', () => {
      speechRate = parseFloat(rateSlider.value) || 1;
      updateRateDisplay();
    });
    updateRateDisplay();

    window.parent.postMessage({ type: 'plugin:ready' }, '*');
  </script>
</body>
</html>
